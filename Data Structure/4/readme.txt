实验四-图及其应用


/*********版本信息*********/
1.c和2.c为按照所需功能分步骤实现的测试版。
3.c为最终版。


/*********实验要求*********/

1、分别给出邻接矩阵和邻接表在无向网的创建算法。

2、基于邻接矩阵实现非递归的深度优先搜索和广度优先搜索。

3、编程实现求无向连通图中的关节点。

4、给定无向网G和起点v0，编程实现输出从顶点v0到其他各顶点的最短路径及其带权长度。最短路径依次输出路径中包含的各顶的信息。


/*********实现思路*********/

1.1、邻接表和邻接矩阵的存储结构容易实现。

1.2、邻接矩阵创建时，直接读入顶点数和边数；通过顶点数约束来循环读入各顶点信息；将各边权初始化为infinity，通过边数的约束循环读入各边信息：通过两端点定位边，然后将权值写入。

1.3、邻接表创建时，同样直接读入顶点数和边数，循环读入各顶点信息；由于各边由指针链接，故在开始定义图时没有存储各边的空间，需要一边读入边一边分配空间，将弧头和边权存入，由尾将边分别定位，衔接到对应顶点的链后。

2.1、邻接矩阵的非递归深度优先遍历需要用栈S来模拟递归过程。遍历图G的各个顶，若未被访问则以该顶为起点进行深度优先遍历。首先访问起点并将其入栈，然后以栈非空为判断条件执行循环：取栈顶元素，找到栈顶元素第一个未被访问的邻顶，访问并入栈，若找不到则将栈顶元素出栈。

2.2、邻接表的广度优先遍历需要用队列Q来存储各个层次。遍历图G的各顶，若未被访问则以该顶为起点进行广度优先遍历。首先访问起点并将其入队列，然后以队列非空为判断条件执行循环：队列首出队列，依次访问它的所有未被访问的邻顶并将邻顶入队列。

3、欲得到G中的所有关节点，则不妨从0号元素存储的顶点开始，深度优先遍历以它的第一个邻顶v0为根的子树H。遍历时用visited[ ]存储深度优先遍历访问的次序，并作为min的初始值。循环判断各个邻顶w是否已被访问：如果不是，则在深度优先生成树中，该邻顶是当前顶v的孩子，递归调用函数，以w作为新的v进行深度优先访问，调用结束后w的low值已求出，将low[w]值与min==visited[v]比较，并把较小的重新赋给min，如果visited[v]较小，则代表v的一个以w为根的子树上，没有与v的祖先相连的边，则v为关节点；如果是，则在深度优先生成树中，该邻顶是当前顶的祖先，将它的访问顺序与min比较并将较小的赋给min。循环结束后把min赋给low[v]。全部调用结束后，判断是否访问完除0号以外的全部结点，如果没有，则代表以v0为根的子树H和G的其他部分之间仅由0号元素连接，则0号元素也为关键节点。

4、v0到其他顶的最短路径：用一个字符型二维数组p来存储到各顶的最短路径上的顶点的信息，整型数组D存储当前最短路径的长度，用整型数组final来代替集合S。首先将v0纳入S中，用v0到其他各顶作为D和p的初始值；然后执行其余顶个数次循环：寻找当前总权最小的非S顶v纳入S中，通过v来寻找并更新到剩余非S顶的最短路径。
